<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>slop counter</title>
<style>
  :root{
    --font: ui-sans-serif, system-ui, -apple-system, "SF Pro Text","Helvetica Neue", Helvetica, Arial, sans-serif;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    --ui-bg: rgba(14,14,14,.80);
    --ui-border: rgba(255,255,255,.14);
    --text: rgba(255,255,255,.92);
    --muted: rgba(255,255,255,.62);
    --round: 16px;
  }
  html,body{height:100%;margin:0;}
  body{background:transparent;color:var(--text);font-family:var(--font);overflow:hidden;}
  #diagram{position:fixed; inset:0; width:100%; height:100%; display:block; cursor:grab;}
  #diagram:active{cursor:grabbing;}

  /* UI */
  #ui{
    position:fixed; left:14px; top:14px;
    width:min(920px, calc(100vw - 28px));
    height:min(760px, calc(100vh - 28px));
    border-radius:var(--round);
    border:1px solid var(--ui-border);
    background:var(--ui-bg);
    backdrop-filter: blur(12px);
    box-shadow: 0 14px 60px rgba(0,0,0,.42);
    overflow:hidden;
    z-index:20;
    transform: translate3d(0px,0px,0px);
    will-change: transform, width, height;
  }
  #ui.hidden .hideWhenHidden{display:none;}
  #ui.hidden #showBtn{display:inline-flex;}
  #showBtn{display:none;}
  #ui.hidden{width:auto;height:auto;border-radius:14px;}

  #topbar{
    display:flex;align-items:center;justify-content:space-between;gap:10px;
    padding:10px;
    border-bottom:1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.03);
    user-select:none;
  }
  #dragHandle{display:flex;align-items:baseline;gap:10px;cursor:grab;touch-action:none;padding:2px 4px;border-radius:12px;}
  #dragHandle:active{cursor:grabbing;}
  .brand{font-weight:950;letter-spacing:.10em;font-size:12px;text-transform:uppercase;color:rgba(255,255,255,.84);}
  .sub{font-weight:700;color:rgba(255,255,255,.48);font-size:11px;letter-spacing:.04em}
  .content{padding:10px;height:calc(100% - 44px);overflow:auto;}

  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .row.tight{gap:6px}
  .btn{
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color:var(--text);
    padding:8px 10px;border-radius:12px;
    cursor:pointer;user-select:none;
    font-weight:850;font-size:12px;
  }
  .btn:hover{background:rgba(255,255,255,.10)}
  .btn:active{transform:translateY(1px)}
  .btn.small{padding:6px 8px;border-radius:10px}
  .btn.green{border-color: rgba(110,255,170,.28)}
  .btn.green:hover{background: rgba(110,255,170,.12)}
  .btn.red{border-color: rgba(255,70,70,.28)}
  .btn.red:hover{background: rgba(255,70,70,.12)}
  .toggle{
    display:inline-flex;align-items:center;gap:8px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.04);
    padding:6px 8px;border-radius:999px;
    font-size:12px;color:var(--muted);
    user-select:none; white-space:nowrap;
  }
  .toggle input{accent-color:white;}

  .tabs{display:flex;gap:8px;flex-wrap:wrap;margin:10px 0}
  .tab{
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.04);
    color: rgba(255,255,255,.78);
    padding:7px 10px;border-radius:999px;
    cursor:pointer;font-weight:950;font-size:12px;
    letter-spacing:.08em;text-transform:uppercase;user-select:none;
  }
  .tab.active{border-color: rgba(120,200,255,.34);background: rgba(120,200,255,.12);color: rgba(255,255,255,.92);}

  .grid{display:grid;grid-template-columns: repeat(3, minmax(0,1fr));gap:10px;}
  @media (max-width: 900px){ .grid{grid-template-columns: repeat(2, minmax(0,1fr));} }
  @media (max-width: 540px){ .grid{grid-template-columns: 1fr;} }

  .card{border:1px solid rgba(255,255,255,.12);background: rgba(255,255,255,.04);border-radius:14px;padding:10px;}
  .titleRow{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:6px;}
  .name{display:flex;align-items:center;gap:8px;font-weight:950;font-size:12px;letter-spacing:.12em;text-transform:uppercase}
  .swatch{width:12px;height:12px;border-radius:4px;border:1px solid rgba(255,255,255,.2);}

  textarea{
    width:100%;height:70px;resize:vertical;
    background: rgba(0,0,0,.26);
    border:1px solid rgba(255,255,255,.12);
    color: var(--text);
    border-radius:12px;padding:8px 10px;
    font-size:12px;outline:none;font-family:var(--font);
  }
  textarea:focus{border-color: rgba(255,255,255,.26)}

  .chips{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px;}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:5px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.14);background: rgba(255,255,255,.08);font-size:12px;cursor:pointer;user-select:none;}
  .chip:hover{background: rgba(255,255,255,.14)}
  .chip .mini{width:10px;height:10px;border-radius:999px;border:1px solid rgba(255,255,255,.22);opacity:.9;}
  .chip.active{border-color: rgba(255,255,255,.34); background: rgba(255,255,255,.14);}
  .chip.shared{border-color: rgba(110,255,170,.35); box-shadow: 0 0 0 2px rgba(110,255,170,.10) inset;}
  .chip.unique{border-color: rgba(255,70,70,.35); box-shadow: 0 0 0 2px rgba(255,70,70,.10) inset;}

  .sectionTitle{margin:10px 0 6px;font-size:11px;letter-spacing:.12em;text-transform:uppercase;color: rgba(255,255,255,.62);}
  .smallmuted{color:rgba(255,255,255,.58); font-size:12px; line-height:1.35}

  .controls{display:grid;grid-template-columns: 1fr 1fr;gap:10px;margin-top:8px;}
  @media (max-width: 780px){ .controls{grid-template-columns:1fr;} }
  .ctrl{border:1px solid rgba(255,255,255,.12);background: rgba(255,255,255,.03);border-radius:14px;padding:10px;}
  .ctrl label{display:flex;justify-content:space-between;gap:10px;align-items:center;font-size:12px;color:rgba(255,255,255,.62);}
  .ctrl input[type="range"]{width:100%;}
  .val{font-family:var(--mono);color:rgba(255,255,255,.86);font-weight:950}

  .table{width:100%;border-collapse:separate;border-spacing:0;border-radius:14px;border:1px solid rgba(255,255,255,.12);background: rgba(255,255,255,.03);overflow:hidden;}
  .table th,.table td{padding:10px 10px;border-bottom:1px solid rgba(255,255,255,.08);vertical-align:top;font-size:12px;}
  .table th{text-align:left;color: rgba(255,255,255,.72);font-weight:950;letter-spacing:.10em;text-transform:uppercase;background: rgba(255,255,255,.02);}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border:1px solid rgba(255,255,255,.14);border-radius:999px;background: rgba(255,255,255,.06);margin:2px 4px 2px 0;white-space:nowrap;}
  .dot{width:9px;height:9px;border-radius:999px;border:1px solid rgba(255,255,255,.22)}
  .warn{border-color: rgba(255,200,80,.40); box-shadow: 0 0 0 2px rgba(255,200,80,.08) inset;}

  /* Resize handles */
  .handle{position:absolute; z-index: 50; background: transparent;}
  .h-n{left:12px; right:12px; top:-6px; height:12px; cursor:ns-resize;}
  .h-s{left:12px; right:12px; bottom:-6px; height:12px; cursor:ns-resize;}
  .h-e{top:12px; bottom:12px; right:-6px; width:12px; cursor:ew-resize;}
  .h-w{top:12px; bottom:12px; left:-6px; width:12px; cursor:ew-resize;}
  .h-se{right:-8px; bottom:-8px; width:18px; height:18px; cursor:nwse-resize;}
  .h-sw{left:-8px; bottom:-8px; width:18px; height:18px; cursor:nesw-resize;}
  .h-ne{right:-8px; top:-8px; width:18px; height:18px; cursor:nesw-resize;}
  .h-nw{left:-8px; top:-8px; width:18px; height:18px; cursor:nwse-resize;}
</style>
</head>
<body>
<canvas id="diagram"></canvas>

<div id="ui">
  <div class="handle h-n" data-h="n"></div>
  <div class="handle h-s" data-h="s"></div>
  <div class="handle h-e" data-h="e"></div>
  <div class="handle h-w" data-h="w"></div>
  <div class="handle h-se" data-h="se"></div>
  <div class="handle h-sw" data-h="sw"></div>
  <div class="handle h-ne" data-h="ne"></div>
  <div class="handle h-nw" data-h="nw"></div>

  <div id="topbar">
    <div id="dragHandle">
      <span class="brand">slop counter</span>
      <span class="sub">pan diagram • fact-check • strict overlaps</span>
    </div>
    <div class="row tight">
      <button class="btn small" id="hideBtn" type="button">Hide</button>
      <button class="btn small" id="showBtn" type="button">Show</button>
    </div>
  </div>

  <div class="content">
    <div class="row tight hideWhenHidden" style="justify-content:space-between">
      <div class="row tight">
        <span class="toggle"><input type="checkbox" id="blackBg"><label for="blackBg">Black bg</label></span>
        <span class="toggle"><input type="checkbox" id="labels" checked><label for="labels">Labels</label></span>
        <span class="toggle"><input type="checkbox" id="slotGuides"><label for="slotGuides">Guides</label></span>
        <span class="toggle"><input type="checkbox" id="sfx" checked><label for="sfx">SFX</label></span>
      </div>
      <div class="row tight">
        <button class="btn small" id="recenterBtn" type="button">Recenter diagram</button>
        <button class="btn small" id="randBtn" type="button">Randomize</button>
        <button class="btn small" id="pngBtn" type="button">Download PNG</button>
        <button class="btn small" id="saveBtn" type="button">Download Data</button>
        <button class="btn small" id="loadBtn" type="button">Load Data</button>
        <button class="btn small red" id="resetBtn" type="button">Reset</button>
        <input id="filePick" type="file" accept="application/json" style="display:none" />
      </div>
    </div>

    <div class="tabs hideWhenHidden" id="tabs">
      <div class="tab active" data-tab="data">Data</div>
      <div class="tab" data-tab="analysis">Analysis</div>
      <div class="tab" data-tab="look">Look</div>
      <div class="tab" data-tab="creatures">Creatures</div>
    </div>

    <div class="tabpane hideWhenHidden" id="pane-data">
      <div class="sectionTitle">Members</div>
      <div class="grid" id="cards"></div>
      <div class="smallmuted" style="margin-top:10px">
        Chips marked <span class="pill"><span class="dot" style="background:rgba(110,255,170,.8)"></span>shared</span> exist in 2+ members.
        Orange ring + <b>!</b> means that overlap pocket is too small with current geometry; adjust <b>Spread</b> / ellipse sizes.
      </div>
    </div>

    <div class="tabpane hideWhenHidden" id="pane-analysis" style="display:none">
      <div class="sectionTitle">Fact check tables</div>
      <div class="smallmuted" style="margin-bottom:10px">
        This is the real categorization. The diagram is just a visualization of these buckets.
      </div>
      <div class="row tight" style="margin-bottom:8px">
        <button class="btn small green" id="suggestBtn" type="button">Suggest</button>
        <span class="smallmuted">Local heuristic suggestions (no internet).</span>
      </div>
      <div id="suggestWrap" class="card" style="display:none; margin-bottom:10px"></div>
      <div id="analysisWrap"></div>
    </div>

    <div class="tabpane hideWhenHidden" id="pane-look" style="display:none">
      <div class="sectionTitle">Look & Feel</div>
      <div class="controls">
        <div class="ctrl"><label>Ellipse width <span class="val" id="rxV"></span></label><input type="range" min="0.14" max="0.45" step="0.01" id="rx"></div>
        <div class="ctrl"><label>Ellipse height <span class="val" id="ryV"></span></label><input type="range" min="0.10" max="0.34" step="0.01" id="ry"></div>
        <div class="ctrl"><label>Spread <span class="val" id="spreadV"></span></label><input type="range" min="0.06" max="0.44" step="0.01" id="spread"></div>
        <div class="ctrl"><label>Fill opacity <span class="val" id="fillV"></span></label><input type="range" min="0.10" max="0.60" step="0.01" id="fill"></div>
        <div class="ctrl"><label>Token size <span class="val" id="tokV"></span></label><input type="range" min="0.85" max="1.70" step="0.01" id="tok"></div>
        <div class="ctrl"><label>Slot spacing <span class="val" id="slotV"></span></label><input type="range" min="12" max="34" step="1" id="slot"></div>
      </div>
      <div class="sectionTitle">Diagram movement</div>
      <div class="smallmuted">Drag empty canvas to pan. Use <b>Recenter diagram</b> to snap back.</div>
    </div>

    <div class="tabpane hideWhenHidden" id="pane-creatures" style="display:none">
      <div class="sectionTitle">Morph critters</div>
      <div class="row tight" style="margin-bottom:10px">
        <span class="toggle"><input type="checkbox" id="creatures"><label for="creatures">Enable</label></span>
        <span class="toggle"><input type="checkbox" id="critGlow" checked><label for="critGlow">Glow</label></span>
        <button class="btn small green" id="spawnBtn" type="button">Spawn</button>
      </div>
      <div class="controls">
        <div class="ctrl"><label>Density <span class="val" id="densV"></span></label><input type="range" min="0" max="28" step="1" id="dens"></div>
        <div class="ctrl"><label>Morph speed <span class="val" id="morphV"></span></label><input type="range" min="0.08" max="0.60" step="0.01" id="morph"></div>
      </div>
      <div class="smallmuted" style="margin-top:8px">Critters morph continuously (frame-by-frame), not “hard swap.”</div>
    </div>
  </div>
</div>

<script>
(() => {
  // -------- SFX (cute bubble clicks)
  let audioCtx=null;
  const sfxToggle=document.getElementById("sfx");
  function ensureAudio(){ audioCtx ||= new (window.AudioContext||window.webkitAudioContext)(); }
  function sfx(type="tap"){
    if(!sfxToggle.checked) return;
    try{
      ensureAudio();
      const t0=audioCtx.currentTime;
      const osc=audioCtx.createOscillator();
      const gain=audioCtx.createGain();
      const bp=audioCtx.createBiquadFilter();
      bp.type="bandpass";
      bp.frequency.setValueAtTime(type==="slider"?1650:1200,t0);
      bp.Q.setValueAtTime(type==="slider"?11:7,t0);
      osc.type="sine";
      const base= type==="slider"?520:320;
      osc.frequency.setValueAtTime(base*3.4,t0);
      osc.frequency.exponentialRampToValueAtTime(base*1.6,t0+0.05);
      gain.gain.setValueAtTime(0.0001,t0);
      gain.gain.exponentialRampToValueAtTime(type==="slider"?0.10:0.14,t0+0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001,t0+0.10);
      osc.connect(bp); bp.connect(gain); gain.connect(audioCtx.destination);
      osc.start(t0); osc.stop(t0+0.12);
    }catch(e){}
  }

  const MEMBERS = ["pet","catsoup","xe","johnwow","bookie","kingcon2k11"];
  const SAVE_KEY = "slop_counter_v14_autosave";

  const state = {
    blackBg:false, showLabels:true, slotGuides:false,
    rxF:0.26, ryF:0.16, spreadF:0.20, fillA:0.28,
    tokenScale:1.05, slotStep:18,
    colors:{}, tokens:Object.fromEntries(MEMBERS.map(m=>[m,[]])),
    pinned:[],
    uiTx:0, uiTy:0, uiHidden:false, uiW:null, uiH:null,
    panX:0, panY:0,
    creaturesOn:false, critGlow:true, density:10, morphSpeed:0.22
  };

  // -------- helpers
  function randColor(){ return {h:Math.floor(Math.random()*360), s:82, l:58}; }
  function hsla(c,a){ return `hsla(${c.h},${c.s}%,${c.l}%,${a})`; }
  function hsl(c){ return `hsl(${c.h},${c.s}%,${c.l}%)`; }
  function parseTokens(txt){ return txt.split(/[\n,]+/g).map(s=>s.trim()).filter(Boolean).slice(0,260); }
  function norm(s){ return s.toLowerCase().trim().replace(/[’']/g,"").replace(/[^a-z0-9\s\-]/g,"").replace(/\s+/g," ").slice(0,80); }
  function normalizeToken(label){
    const n = norm(label);
    if(!n) return null;
    // STRICT: use the normalized phrase as the key (no stemming) to avoid false shared collisions.
    return { key: n, label: n };
  }
  function clamp(v,lo,hi){ return Math.max(lo, Math.min(hi, v)); }
  function rotate(x,y,ang){ return {x:x*Math.cos(ang)-y*Math.sin(ang), y:x*Math.sin(ang)+y*Math.cos(ang)}; }
  function hash(str){
    let h=2166136261;
    for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=Math.imul(h,16777619); }
    return (h>>>0);
  }
  function popcount(x){ let c=0; while(x){ x&=x-1; c++; } return c; }
  function memberMask(m){ return (1<<MEMBERS.indexOf(m)); }
  function maskToMembers(mask){
    const out=[]; for(let i=0;i<MEMBERS.length;i++) if(mask&(1<<i)) out.push(MEMBERS[i]); return out;
  }
  function mixColors(cols){
    let x=0,y=0;
    cols.forEach(c=>{ const a=(c.h/180)*Math.PI; x+=Math.cos(a); y+=Math.sin(a); });
    const avg=Math.atan2(y,x);
    let h=(avg/Math.PI)*180; if(h<0) h+=360;
    const s=Math.round(cols.reduce((a,c)=>a+c.s,0)/cols.length);
    const l=Math.round(cols.reduce((a,c)=>a+c.l,0)/cols.length);
    return {h,s,l};
  }

  // -------- lex + groups
  let lex = new Map();     // key -> node
  let groups = new Map();  // mask -> [node]
  function rebuildLex(){
    const oldPinned = new Set(state.pinned);
    lex = new Map();
    for(const m of MEMBERS){
      for(const raw of state.tokens[m]){
        const t = normalizeToken(raw);
        if(!t) continue;
        const node = lex.get(t.key) || {key:t.key,label:t.label,members:new Set(),mask:0,pinned:oldPinned.has(t.key)};
        node.members.add(m);
        node.mask |= memberMask(m);
        if(t.label.length < node.label.length) node.label = t.label;
        lex.set(t.key,node);
      }
    }
    state.pinned = [...lex.values()].filter(n=>n.pinned).map(n=>n.key);

    groups = new Map();
    for(const n of lex.values()){
      const arr = groups.get(n.mask) || [];
      arr.push(n);
      groups.set(n.mask, arr);
    }
    for(const [mask, arr] of groups.entries()) arr.sort((a,b)=>a.key.localeCompare(b.key));
    buildAnalysis();
  }

  // -------- Tabs
  const tabs = document.getElementById("tabs");
  const panes = {
    data: document.getElementById("pane-data"),
    analysis: document.getElementById("pane-analysis"),
    look: document.getElementById("pane-look"),
    creatures: document.getElementById("pane-creatures"),
  };
  function setTab(name){
    tabs.querySelectorAll(".tab").forEach(t=>t.classList.toggle("active", t.dataset.tab===name));
    for(const k in panes) panes[k].style.display = (k===name) ? "" : "none";
  }
  tabs.addEventListener("click",(e)=>{
    const t=e.target.closest(".tab"); if(!t) return;
    sfx("tap"); setTab(t.dataset.tab);
  });

  // -------- UI cards
  const cards = document.getElementById("cards");
  function buildCards(){
    cards.innerHTML="";
    for(const m of MEMBERS){
      const card=document.createElement("div");
      card.className="card";

      const sw=document.createElement("div");
      sw.className="swatch";
      sw.style.background = hsl(state.colors[m]);

      const name=document.createElement("div");
      name.className="name";
      name.appendChild(sw);
      name.appendChild(document.createTextNode(m));

      const titleRow=document.createElement("div");
      titleRow.className="titleRow";
      titleRow.appendChild(name);

      const clearBtn=document.createElement("button");
      clearBtn.className="btn small";
      clearBtn.type="button";
      clearBtn.textContent="Clear";
      clearBtn.onclick=()=>{
        sfx("tap");
        ta.value="";
        state.tokens[m]=[];
        rebuildLex(); renderChips(); draw();
        autosave();
      };
      titleRow.appendChild(clearBtn);

      const ta=document.createElement("textarea");
      ta.value = state.tokens[m].join(", ");
      ta.placeholder="interests / words… (comma or newline separated)";
      ta.addEventListener("input",()=>{
        state.tokens[m]=parseTokens(ta.value);
        rebuildLex(); renderChips(); placeCache.clear(); draw(); autosave();
      });

      const chips=document.createElement("div");
      chips.className="chips";
      chips.dataset.member=m;

      card.appendChild(titleRow);
      card.appendChild(ta);
      card.appendChild(chips);
      cards.appendChild(card);
    }
  }

  function renderChips(){
    document.querySelectorAll(".chips").forEach(ch=>{
      const m = ch.dataset.member;
      ch.innerHTML="";
      const seen=new Set();
      for(const raw of state.tokens[m]){
        const t=normalizeToken(raw);
        if(!t || seen.has(t.key)) continue;
        seen.add(t.key);
        const node=lex.get(t.key); if(!node) continue;

        const chip=document.createElement("div");
        chip.className="chip";
        const dot=document.createElement("div");
        dot.className="mini";
        dot.style.background = hsl(state.colors[m]);
        chip.appendChild(dot);
        chip.appendChild(document.createTextNode(node.label));
        chip.classList.add(node.members.size>=2 ? "shared" : "unique");
        if(node.pinned) chip.classList.add("active");

        chip.onclick=()=>{
          sfx("tap");
          node.pinned=!node.pinned;
          rebuildLex(); renderChips(); draw(); autosave();
        };
        ch.appendChild(chip);
      }
    });
  }

  // -------- Fact check tables
  const analysisWrap=document.getElementById("analysisWrap");
  const suggestWrap=document.getElementById("suggestWrap");
  function pill(m){
    const c=state.colors[m]||{h:0,s:0,l:50};
    return `<span class="pill"><span class="dot" style="background:${hsl(c)}"></span>${m}</span>`;
  }
  function buildAnalysis(){
    const uniques = new Map(MEMBERS.map(m=>[m,[]]));
    const multi = [];
    for(const [mask, arr] of groups.entries()){
      const ms = maskToMembers(mask);
      if(ms.length===1) uniques.get(ms[0]).push(...arr.map(n=>n.label));
      else multi.push({mask, members:ms, tokens:arr.map(n=>n.label)});
    }
    multi.sort((a,b)=> (b.members.length-a.members.length) || a.members.join(",").localeCompare(b.members.join(",")));

    const pairRows=[];
    for(let i=0;i<MEMBERS.length;i++){
      for(let j=i+1;j<MEMBERS.length;j++){
        const mask=(1<<i)|(1<<j);
        const arr=groups.get(mask)||[];
        pairRows.push({a:MEMBERS[i], b:MEMBERS[j], tokens:arr.map(n=>n.label)});
      }
    }
    pairRows.sort((x,y)=> (y.tokens.length-x.tokens.length) || (x.a+x.b).localeCompare(y.a+y.b));

    let html="";
    html += `<div class="sectionTitle">Pairwise similarities</div>`;
    html += `<table class="table"><thead><tr><th>Pair</th><th>Shared tokens</th><th>Count</th></tr></thead><tbody>`;
    for(const r of pairRows){
      const toks = r.tokens.length ? r.tokens.map(t=>`<span class="pill">${t}</span>`).join("") : `<span class="smallmuted">—</span>`;
      html += `<tr><td>${pill(r.a)} ${pill(r.b)}</td><td>${toks}</td><td><span class="val">${r.tokens.length}</span></td></tr>`;
    }
    html += `</tbody></table>`;

    html += `<div class="sectionTitle" style="margin-top:14px">Unique differences</div>`;
    html += `<table class="table"><thead><tr><th>Member</th><th>Unique tokens</th><th>Count</th></tr></thead><tbody>`;
    for(const m of MEMBERS){
      const arr=(uniques.get(m)||[]).slice().sort();
      const toks = arr.length ? arr.map(t=>`<span class="pill">${t}</span>`).join("") : `<span class="smallmuted">—</span>`;
      html += `<tr><td>${pill(m)}</td><td>${toks}</td><td><span class="val">${arr.length}</span></td></tr>`;
    }
    html += `</tbody></table>`;

    html += `<div class="sectionTitle" style="margin-top:14px">Group overlaps (3+)</div>`;
    html += `<table class="table"><thead><tr><th>Group</th><th>Shared tokens</th><th>Count</th></tr></thead><tbody>`;
    const multi3 = multi.filter(x=>x.members.length>=3);
    if(!multi3.length){
      html += `<tr><td colspan="3"><span class="smallmuted">No 3+ overlaps yet.</span></td></tr>`;
    }else{
      for(const r of multi3){
        const toks = r.tokens.length ? r.tokens.map(t=>`<span class="pill">${t}</span>`).join("") : `<span class="smallmuted">—</span>`;
        html += `<tr><td>${r.members.map(m=>pill(m)).join(" ")}</td><td>${toks}</td><td><span class="val">${r.tokens.length}</span></td></tr>`;
      }
    }
    html += `</tbody></table>`;
    analysisWrap.innerHTML = html;
  }

  // -------- Smart suggestions (offline heuristic)
  const SUGGEST_MAP = [
    { match: /\b(editing|editor|cutting|cuts)\b/i, add: ["post-production","film industry","timeline workflow","rhythm & pacing"] },
    { match: /\b(clean editing|clean cut|tight edit)\b/i, add: ["commercial editing","agency-style polish","brand-safe pacing"] },
    { match: /\b(color|grading|grade|davinci)\b/i, add: ["color pipeline","look development","deliverables/QC"] },
    { match: /\b(vfx|after effects|ae|compositing|comp)\b/i, add: ["motion graphics","compositing pipeline","render management"] },
    { match: /\b(3d|blender|c4d|cinema 4d)\b/i, add: ["CG pipeline","asset workflow","lighting & materials"] },
    { match: /\b(sound design|sound|mixing|audio)\b/i, add: ["post audio","mix bus discipline","texture design"] },
    { match: /\b(ai|midjourney|runway|sora|veo|kling|luma)\b/i, add: ["model-driven workflow","promptcraft","hybrid post"] },
    { match: /\b(stage visuals|projection|touchdesigner|td)\b/i, add: ["live visuals","show control","real-time rendering"] },
    { match: /\b(brand|branding|logo|identity)\b/i, add: ["commercial identity","client-facing polish","systems thinking"] },
    { match: /\b(animation|animating|motion)\b/i, add: ["timing","easing curves","frame cadence"] },
  ];
  function collectByMember(){
    const out={};
    for(const m of MEMBERS){
      const set=new Map();
      for(const raw of state.tokens[m]){
        const t=normalizeToken(raw); if(!t) continue;
        set.set(t.key,t.label);
      }
      out[m]=set;
    }
    return out;
  }
  function suggestionsFromToken(label){
    const out=new Set();
    for(const rule of SUGGEST_MAP) if(rule.match.test(label)) rule.add.forEach(x=>out.add(x));
    return [...out];
  }
  function buildSuggestions(){
    const by=collectByMember();
    const tokMembers=new Map(); // key -> {label, members:Set}
    for(const m of MEMBERS){
      for(const [k, lab] of by[m].entries()){
        const obj = tokMembers.get(k) || {label:lab, members:new Set()};
        obj.members.add(m);
        if(lab.length < obj.label.length) obj.label=lab;
        tokMembers.set(k,obj);
      }
    }
    const suggestions=[];
    const seen=new Set();
    for(const [k,obj] of tokMembers.entries()){
      const base=obj.label;
      const recs=suggestionsFromToken(base);
      if(!recs.length) continue;
      const targets=[...obj.members].sort();
      for(const rec of recs){
        const rk = norm(rec);
        // If all targets already have it, skip
        let missing=false;
        for(const m of targets){ if(!by[m].has(rk)){ missing=true; break; } }
        if(!missing) continue;
        const id = targets.join("|") + ">>" + rk;
        if(seen.has(id)) continue;
        seen.add(id);
        suggestions.push({targets, base, rec});
      }
    }
    suggestions.sort((a,b)=> (b.targets.length-a.targets.length) || a.rec.localeCompare(b.rec));
    return suggestions.slice(0,80);
  }
  function renderSuggestions(){
    const sugg=buildSuggestions();
    if(!sugg.length){
      suggestWrap.style.display="";
      suggestWrap.innerHTML = `<div class="smallmuted">No suggestions yet. Add concrete tokens like “editing”, “vfx”, “branding”, “ai”.</div>`;
      return;
    }
    suggestWrap.style.display="";
    let html=`<div class="smallmuted" style="margin-bottom:8px">Click <b>Add</b> to apply a suggestion to the detected group.</div>`;
    html+=`<table class="table"><thead><tr><th>Group</th><th>Because</th><th>Suggested</th><th></th></tr></thead><tbody>`;
    for(const s of sugg){
      html+=`<tr>
        <td>${s.targets.map(m=>pill(m)).join(" ")}</td>
        <td><span class="pill">${s.base}</span></td>
        <td><span class="pill">${s.rec}</span></td>
        <td><button class="btn small green" data-add="${encodeURIComponent(JSON.stringify(s))}">Add</button></td>
      </tr>`;
    }
    html+=`</tbody></table>`;
    suggestWrap.innerHTML=html;
    suggestWrap.querySelectorAll("button[data-add]").forEach(btn=>{
      btn.addEventListener("click",()=>{
        sfx("tap");
        const s=JSON.parse(decodeURIComponent(btn.getAttribute("data-add")));
        for(const m of s.targets) state.tokens[m].push(s.rec);
        rebuildLex(); buildCards(); renderChips(); placeCache.clear(); draw(); autosave();
        renderSuggestions();
      });
    });
  }
  document.getElementById("suggestBtn").addEventListener("click",()=>{ sfx("tap"); renderSuggestions(); });

  // -------- Canvas + drawing
  const canvas=document.getElementById("diagram");
  const ctx=canvas.getContext("2d");
  function resize(){
    canvas.width = Math.floor(window.innerWidth * devicePixelRatio);
    canvas.height = Math.floor(window.innerHeight * devicePixelRatio);
    canvas.style.width = window.innerWidth + "px";
    canvas.style.height = window.innerHeight + "px";
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    placeCache.clear();
    draw();
  }
  window.addEventListener("resize", resize);

  function memberLayout(){
    const W=window.innerWidth,H=window.innerHeight;
    const cx=W/2 + state.panX, cy=H/2 + state.panY;
    const min=Math.min(W,H);
    const rx=min*state.rxF;
    const ry=min*state.ryF;
    const safeR = Math.min(min*state.spreadF, (min*0.46) - Math.max(rx,ry) - 18);
    const R=Math.max(30,safeR);
    const pos={};
    MEMBERS.forEach((m,i)=>{
      const a=-Math.PI/2 + i*(Math.PI*2/MEMBERS.length);
      pos[m]={x:cx+Math.cos(a)*R, y:cy+Math.sin(a)*R, a};
    });
    return {cx,cy,pos,rx,ry,R};
  }

  function insideMember(x,y,m,layout){
    const p=layout.pos[m];
    const rot=p.a + Math.PI/2;
    const dx=x-p.x, dy=y-p.y;
    const local=rotate(dx,dy,-rot);
    const v=(local.x*local.x)/(layout.rx*layout.rx) + (local.y*local.y)/(layout.ry*layout.ry);
    return v<=1.0;
  }
  function insideMask(x,y,mask,layout){
    for(let i=0;i<MEMBERS.length;i++){
      const inSet=!!(mask&(1<<i));
      const inside=insideMember(x,y,MEMBERS[i],layout);
      if(inSet && !inside) return false;
      if(!inSet && inside) return false;
    }
    return true;
  }

  function maskAngle(mask, layout){
    let sx=0,sy=0;
    for(let i=0;i<MEMBERS.length;i++){
      if(mask&(1<<i)){
        const a=layout.pos[MEMBERS[i]].a;
        sx+=Math.cos(a); sy+=Math.sin(a);
      }
    }
    return Math.atan2(sy,sx);
  }
  function ringRadius(k, layout){
    if(k>=6) return 0;
    const table={5:0.22,4:0.42,3:0.66,2:0.92};
    return layout.R * (table[k] ?? 0.78);
  }
  function overlapAnchor(mask, layout){
    const k=popcount(mask);
    const {cx,cy}=layout;
    if(k===6) return {x:cx,y:cy,ang:0,k};
    const ang=maskAngle(mask,layout);
    const r=ringRadius(k,layout);
    const pull = k>=3 ? 0.08 : 0.03;
    return {x: cx + Math.cos(ang)*r*(1-pull), y: cy + Math.sin(ang)*r*(1-pull), ang, k};
  }
  function slotOffset(i, step){
    if(i===0) return {dx:0,dy:0};
    const layer=Math.floor((Math.sqrt(i)+1)/2);
    const legLen=layer*2;
    const maxI=(2*layer+1)**2;
    const d=maxI-i;
    const leg=Math.floor(d/legLen);
    const pos=d%legLen;
    let x=layer,y=layer;
    if(leg===0){ x=layer-pos; y=layer; }
    else if(leg===1){ x=-layer; y=layer-pos; }
    else if(leg===2){ x=-layer+pos; y=-layer; }
    else { x=layer; y=-layer+pos; }
    return {dx:x*step, dy:y*step};
  }

  // Strict placement cache
  const placeCache=new Map(); // key|sig -> {x,y}
  function layoutSig(layout){
    return `${layout.cx.toFixed(1)}|${layout.cy.toFixed(1)}|${layout.rx.toFixed(1)}|${layout.ry.toFixed(1)}|${layout.R.toFixed(1)}|${state.slotStep}`;
  }
  function findFeasiblePoint(targetX,targetY,mask,layout,seed){
    if(insideMask(targetX,targetY,mask,layout)) return {x:targetX,y:targetY, ok:true};
    const step=Math.max(10,state.slotStep*0.9);
    const maxR=Math.max(layout.R*1.25, 520);
    const ang0=((seed%628)/100);
    for(let r=step;r<=maxR;r+=step){
      const samples=Math.max(10, Math.min(44, Math.floor(r/step)*6));
      for(let i=0;i<samples;i++){
        const a=ang0 + (i/samples)*Math.PI*2;
        const x=targetX + Math.cos(a)*r;
        const y=targetY + Math.sin(a)*r;
        if(insideMask(x,y,mask,layout)) return {x,y, ok:true};
      }
    }
    return {x:targetX,y:targetY, ok:false};
  }
  function tokenPosition(node, layout){
    const mask=node.mask;
    const a=overlapAnchor(mask,layout);
    const arr=groups.get(mask)||[];
    const idx=arr.findIndex(n=>n.key===node.key);
    const {dx,dy}=slotOffset(Math.max(0,idx), state.slotStep);
    const rot=a.ang + Math.PI/2;
    const r=rotate(dx,dy,rot);
    const rawX=a.x + r.x;
    const rawY=a.y + r.y;

    const sig=layoutSig(layout);
    const cacheKey=`${node.key}|${sig}`;
    const prev=placeCache.get(cacheKey);
    if(prev && insideMask(prev.x,prev.y,mask,layout)) return {x:prev.x,y:prev.y, ok:true};

    const p=findFeasiblePoint(rawX,rawY,mask,layout,hash(node.key));
    if(p.ok) placeCache.set(cacheKey,{x:p.x,y:p.y});
    return {x:p.x,y:p.y, ok:p.ok};
  }

  function drawEllipse(x,y,rx,ry,rot,fill,stroke){
    ctx.save();
    ctx.translate(x,y); ctx.rotate(rot);
    ctx.beginPath();
    ctx.ellipse(0,0,rx,ry,0,0,Math.PI*2);
    if(fill){ ctx.fillStyle=fill; ctx.fill(); }
    if(stroke){ ctx.strokeStyle=stroke; ctx.lineWidth=1.5; ctx.stroke(); }
    ctx.restore();
  }

  function drawCenterLabel(cx,cy){
    const text="slop shop";
    ctx.save();
    ctx.font=`950 20px ${getComputedStyle(document.documentElement).getPropertyValue('--font')||'system-ui'}`;
    const tw=ctx.measureText(text).width;
    const bw=tw+26, bh=34;
    const x=cx-bw/2, y=cy-bh/2;

    ctx.shadowColor = state.blackBg ? "rgba(255,255,255,.18)" : "rgba(0,0,0,.14)";
    ctx.shadowBlur=18;
    ctx.fillStyle = state.blackBg ? "rgba(0,0,0,.42)" : "rgba(255,255,255,.34)";
    ctx.strokeStyle = state.blackBg ? "rgba(255,255,255,.22)" : "rgba(0,0,0,.16)";
    ctx.lineWidth=1.2;
    ctx.beginPath();
    if(ctx.roundRect) ctx.roundRect(x,y,bw,bh,14); else ctx.rect(x,y,bw,bh);
    ctx.fill(); ctx.stroke();
    ctx.shadowBlur=0;
    ctx.fillStyle = state.blackBg ? "rgba(255,255,255,.92)" : "rgba(10,10,10,.88)";
    ctx.fillText(text, x+13, y+24);
    ctx.restore();
  }

  function drawMemberLabel(m, layout){
    const {cx,cy,pos,rx,ry}=layout;
    const p=pos[m];
    const rot=p.a + Math.PI/2;

    let dx=p.x-cx, dy=p.y-cy;
    const len=Math.hypot(dx,dy)||1;
    dx/=len; dy/=len;

    const local=rotate(dx,dy,-rot);
    const denom=Math.sqrt((local.x*local.x)/(rx*rx)+(local.y*local.y)/(ry*ry))||1;
    const scale=1/denom;
    const onEdgeLocal={x:local.x*scale,y:local.y*scale};
    const onEdge=rotate(onEdgeLocal.x,onEdgeLocal.y,rot);

    const ax=p.x+onEdge.x, ay=p.y+onEdge.y;
    const labelX=ax+dx*16, labelY=ay+dy*16;

    const text=m;
    ctx.save();
    ctx.font=`900 13px ${getComputedStyle(document.documentElement).getPropertyValue('--font')||'system-ui'}`;
    const tw=ctx.measureText(text).width;
    const bw=tw+16, bh=20;
    const bx=labelX-bw/2, by=labelY-bh/2;

    ctx.strokeStyle = state.blackBg ? "rgba(255,255,255,.18)" : "rgba(0,0,0,.16)";
    ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(labelX,labelY); ctx.stroke();

    ctx.fillStyle = state.blackBg ? "rgba(0,0,0,.40)" : "rgba(255,255,255,.28)";
    ctx.strokeStyle = state.blackBg ? "rgba(255,255,255,.18)" : "rgba(0,0,0,.14)";
    ctx.beginPath();
    if(ctx.roundRect) ctx.roundRect(bx,by,bw,bh,10); else ctx.rect(bx,by,bw,bh);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = state.blackBg ? "rgba(255,255,255,.92)" : "rgba(10,10,10,.88)";
    ctx.fillText(text, bx+8, by+14);
    ctx.restore();
  }

  function drawGuides(layout){
    if(!state.slotGuides) return;
    ctx.save();
    ctx.strokeStyle = state.blackBg ? "rgba(255,255,255,.08)" : "rgba(0,0,0,.08)";
    ctx.lineWidth=1;
    const {cx,cy,R}=layout;
    const rings=[0.92,0.66,0.42,0.22];
    for(const f of rings){ ctx.beginPath(); ctx.arc(cx,cy,R*f,0,Math.PI*2); ctx.stroke(); }
    ctx.restore();
  }

  // -------- Morph critters (continuous genome interpolation)
  const creatures=[];
  function prng(seed){
    let s=seed>>>0;
    return ()=> (s=(s*1664525+1013904223)>>>0)/4294967296;
  }
  function rrange(r,a,b){ return a+(b-a)*r(); }
  function genome(seed){
    const r=prng(seed);
    return {
      bodyW: rrange(r, 14, 26),
      bodyH: rrange(r, 8, 18),
      headW: rrange(r, 7, 16),
      headH: rrange(r, 6, 14),
      neck:  rrange(r, 0, 1.3),
      wing:  rrange(r, 0, 1.3),
      tail:  rrange(r, 0, 1.3),
      spike: rrange(r, 0, 1.3),
      beak:  rrange(r, 0, 1.3),
      ear:   rrange(r, 0, 1.3),
      tilt:  rrange(r, -0.35, 0.35),
      offX:  rrange(r, -4, 4),
      offY:  rrange(r, -3, 3)
    };
  }
  function lerp(a,b,t){ return a+(b-a)*t; }
  function mixG(a,b,t){
    const o={};
    for(const k in a) o[k]=lerp(a[k],b[k],t);
    return o;
  }
  function spawnCreatures(n){
    const W=window.innerWidth, H=window.innerHeight;
    for(let i=0;i<n;i++){
      const seed=(Math.random()*1e9)|0;
      const seed2=(seed*1103515245+12345)|0;
      creatures.push({
        x: Math.random()*(W+360)-180,
        y: H-30 - Math.random()*12,
        vx: (22+Math.random()*58) * (Math.random()<0.5?1:-1),
        s: 0.70 + Math.random()*0.90,
        c: randColor(),
        bob: Math.random()*6.28,
        seed,
        t: Math.random(),
        gA: genome(seed),
        gB: genome(seed2)
      });
    }
  }
  function ensureCreatures(){
    if(!state.creaturesOn) return;
    if(creatures.length < state.density) spawnCreatures(state.density - creatures.length);
    if(creatures.length > state.density) creatures.splice(0, creatures.length - state.density);
  }
  function tickCreatures(dt){
    const W=window.innerWidth;
    for(const cr of creatures){
      cr.x += cr.vx*dt;
      cr.bob += dt*2.0;
      cr.t += dt*state.morphSpeed;
      if(cr.t >= 1){
        cr.t = 0;
        cr.seed = (Math.random()*1e9)|0;
        cr.c = randColor();
        cr.gA = cr.gB;
        cr.gB = genome((cr.seed*1103515245+12345)|0);
      }
      if(cr.x<-260) cr.x=W+260;
      if(cr.x>W+260) cr.x=-260;
    }
  }
  function drawCreature(cr){
    const x=cr.x, y=cr.y + Math.sin(cr.bob)*2.0;
    const s=cr.s;
    const glow=state.critGlow;

    const t = 0.5 - 0.5*Math.cos(Math.PI*2*cr.t); // smooth cyclic
    const g = mixG(cr.gA, cr.gB, t);

    const fill=hsla(cr.c, 0.52);
    const stroke= state.blackBg ? "rgba(255,255,255,.20)" : "rgba(0,0,0,.18)";

    ctx.save();
    if(glow){ ctx.shadowColor = hsla(cr.c,0.60); ctx.shadowBlur=14; }
    ctx.fillStyle=fill; ctx.strokeStyle=stroke; ctx.lineWidth=1.1;

    // ground
    ctx.globalAlpha=0.78;
    ctx.beginPath(); ctx.ellipse(x, y+14*s, 22*s, 6*s, 0, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;

    const dir = cr.vx>=0 ? 1 : -1;
    ctx.translate(x,y);
    ctx.scale(dir*s, s);
    ctx.rotate(g.tilt*0.12);

    ctx.translate(g.offX, g.offY);

    const BW=g.bodyW, BH=g.bodyH;
    const HW=g.headW, HH=g.headH;

    // body + belly
    ctx.beginPath(); ctx.ellipse(0, 10, BW*0.9, BH*0.65, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.save(); ctx.globalAlpha=0.18; ctx.fillStyle="white";
    ctx.beginPath(); ctx.ellipse(-BW*0.10, 12, BW*0.45, BH*0.30, -0.4, 0, Math.PI*2); ctx.fill();
    ctx.restore(); ctx.fillStyle=fill; ctx.strokeStyle=stroke;

    // head
    ctx.beginPath(); ctx.ellipse(BW*0.75, 2, HW*0.70, HH*0.70, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();

    // beak-ish / snout
    const be = g.beak;
    if(be>0.25){
      ctx.beginPath();
      ctx.moveTo(BW*1.05, 2);
      ctx.lineTo(BW*1.05 + 10*be, 4);
      ctx.lineTo(BW*1.05, 8);
      ctx.closePath(); ctx.fill(); ctx.stroke();
    }

    // ears
    const ea=g.ear;
    if(ea>0.25){
      ctx.beginPath();
      ctx.moveTo(BW*0.55, -6);
      ctx.lineTo(BW*0.62, -16*ea);
      ctx.lineTo(BW*0.78, -5);
      ctx.closePath(); ctx.fill(); ctx.stroke();
    }

    // neck (long-neck vibe)
    const nk=g.neck;
    if(nk>0.25){
      const segs = Math.max(2, Math.floor(2 + nk*6));
      for(let i=0;i<segs;i++){
        const ny = 2 - i*8;
        ctx.beginPath();
        const w = 7 + nk*3;
        ctx.roundRect ? ctx.roundRect(BW*0.45, ny-8, w, 9, 6) : ctx.rect(BW*0.45, ny-8, w, 9);
        ctx.fill(); ctx.stroke();
      }
    }

    // wings
    const wi=g.wing;
    if(wi>0.25){
      const count = Math.max(2, Math.floor(2 + wi*3));
      for(let i=0;i<count;i++){
        ctx.beginPath();
        ctx.moveTo(-BW*0.85, 12+i*2);
        ctx.lineTo(-BW*(1.15+0.18*wi), 16+i*3);
        ctx.lineTo(-BW*0.85, 18+i*2);
        ctx.closePath(); ctx.fill(); ctx.stroke();
      }
    }

    // tail
    const ta=g.tail;
    if(ta>0.25){
      ctx.save();
      ctx.lineWidth=2.0; ctx.strokeStyle=stroke;
      ctx.beginPath();
      ctx.moveTo(-BW*0.95, 12);
      ctx.bezierCurveTo(-BW*(1.35*ta), 6, -BW*(1.10*ta), -10*ta, -BW*(0.55*ta), -8*ta);
      ctx.stroke();
      ctx.restore();
    }

    // spikes
    const sp=g.spike;
    if(sp>0.35){
      const n = Math.max(1, Math.floor(1 + sp*4));
      for(let i=0;i<n;i++){
        const sx = -BW*0.15 + i*(BW*0.18);
        const sy = -BH*0.55 - i*1;
        ctx.beginPath();
        ctx.moveTo(sx, sy+10);
        ctx.lineTo(sx-4, sy-2-6*sp);
        ctx.lineTo(sx+4, sy);
        ctx.closePath(); ctx.fill(); ctx.stroke();
      }
    }

    // legs (simple)
    const leg = 2 + Math.floor(2 + (BH/18)*2);
    for(let i=0;i<3;i++){
      const lx = -BW*0.35 + i*(BW*0.30);
      ctx.beginPath();
      ctx.roundRect ? ctx.roundRect(lx, 18, 7, 8, 6) : ctx.rect(lx,18,7,8);
      ctx.fill(); ctx.stroke();
    }

    // eyes
    ctx.shadowBlur=0;
    ctx.fillStyle = state.blackBg ? "rgba(255,255,255,.92)" : "rgba(10,10,10,.82)";
    ctx.beginPath(); ctx.arc(BW*0.70, 1, 1.6, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(BW*0.82, 1, 1.6, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function drawCreatures(){
    if(!state.creaturesOn) return;
    const W=window.innerWidth, H=window.innerHeight;
    ctx.save();
    ctx.strokeStyle = state.blackBg ? "rgba(255,255,255,.10)" : "rgba(0,0,0,.10)";
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(0,H-28); ctx.lineTo(W,H-28); ctx.stroke();
    ctx.restore();
    for(const cr of creatures) drawCreature(cr);
  }

  // -------- draw loop
  function draw(){
    const W=window.innerWidth,H=window.innerHeight;
    ctx.clearRect(0,0,W,H);
    if(state.blackBg){ ctx.fillStyle="black"; ctx.fillRect(0,0,W,H); }

    const layout=memberLayout();
    const {cx,cy,pos,rx,ry}=layout;

    // ellipses
    for(const m of MEMBERS){
      const p=pos[m];
      drawEllipse(p.x,p.y,rx,ry,p.a+Math.PI/2, hsla(state.colors[m], state.fillA), "rgba(0,0,0,.72)");
    }

    drawGuides(layout);
    drawCenterLabel(cx,cy);

    // tokens
    for(const node of lex.values()){
      const tp=tokenPosition(node,layout);
      const mix=mixColors([...node.members].map(m=>state.colors[m]));
      const isPinned=node.pinned;
      const radius=(isPinned?18:12)*state.tokenScale;

      // optional tether for shared tokens only
      if(node.members.size>=2){
        ctx.save();
        ctx.strokeStyle = state.blackBg ? "rgba(255,255,255,.08)" : "rgba(0,0,0,.08)";
        ctx.lineWidth=1;
        ctx.beginPath(); ctx.moveTo(tp.x,tp.y); ctx.lineTo(cx,cy); ctx.stroke();
        ctx.restore();
      }

      const g=ctx.createRadialGradient(tp.x,tp.y,0,tp.x,tp.y,radius*2.6);
      g.addColorStop(0, hsla(mix, isPinned?0.30:0.16));
      g.addColorStop(1, hsla(mix, 0));
      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(tp.x,tp.y,radius*2.6,0,Math.PI*2); ctx.fill();

      ctx.strokeStyle = tp.ok
        ? (node.members.size>=2 ? "rgba(110,255,170,.32)" : "rgba(255,70,70,.32)")
        : "rgba(255,200,80,.70)";
      ctx.lineWidth = isPinned?1.2:0.9;
      ctx.beginPath(); ctx.arc(tp.x,tp.y,radius,0,Math.PI*2); ctx.stroke();

      if(!tp.ok){
        ctx.save();
        ctx.fillStyle = state.blackBg ? "rgba(255,200,80,.92)" : "rgba(120,70,0,.88)";
        ctx.font = `950 ${11*state.tokenScale}px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')||'monospace'}`;
        ctx.fillText("!", tp.x-4, tp.y+4);
        ctx.restore();
      }

      ctx.font = `${isPinned?900:800} ${(isPinned?13:11)*state.tokenScale}px ${getComputedStyle(document.documentElement).getPropertyValue('--font')||'system-ui'}`;
      ctx.fillStyle = state.blackBg ? (isPinned?"rgba(255,255,255,.92)":"rgba(255,255,255,.72)") : (isPinned?"rgba(10,10,10,.88)":"rgba(10,10,10,.66)");
      ctx.fillText(node.label, tp.x+10, tp.y+4);
    }

    if(state.showLabels) for(const m of MEMBERS) drawMemberLabel(m,layout);

    drawCreatures();
  }

  // -------- PNG export
  function exportPNG(){
    sfx("tap");
    const W=window.innerWidth,H=window.innerHeight;
    const out=document.createElement("canvas");
    const scale=2;
    out.width=Math.floor(W*scale);
    out.height=Math.floor(H*scale);
    const octx=out.getContext("2d");
    octx.setTransform(scale,0,0,scale,0,0);
    if(state.blackBg){ octx.fillStyle="black"; octx.fillRect(0,0,W,H); }
    octx.drawImage(canvas,0,0,W,H);
    const a=document.createElement("a");
    a.download="slop_counter.png";
    a.href=out.toDataURL("image/png");
    a.click();
  }

  // -------- Save/load
  function snapshot(){
    return {
      version: 14,
      ts: Date.now(),
      tokens: state.tokens,
      colors: state.colors,
      pinned: state.pinned,
      prefs: {
        blackBg:state.blackBg, showLabels:state.showLabels, slotGuides:state.slotGuides,
        rxF:state.rxF, ryF:state.ryF, spreadF:state.spreadF, fillA:state.fillA,
        tokenScale:state.tokenScale, slotStep:state.slotStep,
        panX: state.panX, panY: state.panY
      },
      ui: { tx: state.uiTx, ty: state.uiTy, hidden: state.uiHidden, w: state.uiW, h: state.uiH },
      sfx: { enabled: sfxToggle.checked },
      crit: { enabled: state.creaturesOn, glow: state.critGlow, density: state.density, morphSpeed: state.morphSpeed }
    };
  }
  function autosave(){ try{ localStorage.setItem(SAVE_KEY, JSON.stringify(snapshot())); }catch(e){} }
  function applySnapshot(s){
    if(!s || typeof s!=="object") throw new Error("bad data");
    if(s.tokens) MEMBERS.forEach(m=> state.tokens[m]=Array.isArray(s.tokens[m])?s.tokens[m]:[]);
    if(s.colors) MEMBERS.forEach(m=>{ const c=s.colors[m]; if(c && typeof c.h==="number") state.colors[m]=c; });
    if(Array.isArray(s.pinned)) state.pinned=s.pinned;
    if(s.prefs){
      state.blackBg=!!s.prefs.blackBg;
      state.showLabels=(s.prefs.showLabels!==false);
      state.slotGuides=!!s.prefs.slotGuides;
      if(typeof s.prefs.rxF==="number") state.rxF=clamp(s.prefs.rxF,0.14,0.45);
      if(typeof s.prefs.ryF==="number") state.ryF=clamp(s.prefs.ryF,0.10,0.34);
      if(typeof s.prefs.spreadF==="number") state.spreadF=clamp(s.prefs.spreadF,0.06,0.44);
      if(typeof s.prefs.fillA==="number") state.fillA=clamp(s.prefs.fillA,0.10,0.60);
      if(typeof s.prefs.tokenScale==="number") state.tokenScale=clamp(s.prefs.tokenScale,0.85,1.70);
      if(typeof s.prefs.slotStep==="number") state.slotStep=clamp(s.prefs.slotStep,12,34);
      if(typeof s.prefs.panX==="number") state.panX=s.prefs.panX;
      if(typeof s.prefs.panY==="number") state.panY=s.prefs.panY;
    }
    if(s.ui){
      if(typeof s.ui.tx==="number") state.uiTx=s.ui.tx;
      if(typeof s.ui.ty==="number") state.uiTy=s.ui.ty;
      state.uiHidden=!!s.ui.hidden;
      if(typeof s.ui.w==="number") state.uiW=s.ui.w;
      if(typeof s.ui.h==="number") state.uiH=s.ui.h;
    }
    if(s.sfx && typeof s.sfx.enabled==="boolean") sfxToggle.checked=s.sfx.enabled;
    if(s.crit){
      state.creaturesOn=!!s.crit.enabled;
      if(typeof s.crit.glow==="boolean") state.critGlow=s.crit.glow;
      if(typeof s.crit.density==="number") state.density=clamp(s.crit.density,0,28);
      if(typeof s.crit.morphSpeed==="number") state.morphSpeed=clamp(s.crit.morphSpeed,0.08,0.60);
    }
  }

  // -------- UI hide/show + drag + resize
  const ui=document.getElementById("ui");
  const hideBtn=document.getElementById("hideBtn");
  const showBtn=document.getElementById("showBtn");
  function setHidden(v){
    state.uiHidden=!!v;
    ui.classList.toggle("hidden", state.uiHidden);
  }
  hideBtn.addEventListener("click",(e)=>{ e.stopPropagation(); sfx("tap"); setHidden(true); autosave(); });
  showBtn.addEventListener("click",(e)=>{ e.stopPropagation(); sfx("tap"); setHidden(false); autosave(); });
  ui.addEventListener("dblclick",(e)=>{
    const tag=(e.target && e.target.tagName)?e.target.tagName.toLowerCase():"";
    if(["textarea","input","select","button","label"].includes(tag)) return;
    sfx("tap"); setHidden(!state.uiHidden); autosave();
  });
  window.addEventListener("keydown",(e)=>{ if(e.key==="Escape"){ sfx("tap"); setHidden(!state.uiHidden); autosave(); } });

  // drag panel
  const dragHandle=document.getElementById("dragHandle");
  let dragging=false, dsx=0,dsy=0, baseTx=0, baseTy=0;
  function setUITransform(tx,ty){
    state.uiTx=tx; state.uiTy=ty;
    ui.style.transform=`translate3d(${tx}px,${ty}px,0)`;
  }
  function clampTransform(tx,ty){
    const pad=8;
    const r=ui.getBoundingClientRect();
    const baseL=14, baseT=14;
    const W=window.innerWidth, H=window.innerHeight;
    const curL=baseL+tx, curT=baseT+ty;
    const maxL=W-r.width-pad;
    const maxT=H-r.height-pad;
    const clL=Math.max(pad, Math.min(maxL, curL));
    const clT=Math.max(pad, Math.min(maxT, curT));
    return {tx:clL-baseL, ty:clT-baseT};
  }
  dragHandle.addEventListener("pointerdown",(e)=>{
    sfx("tap");
    dragging=true;
    dragHandle.setPointerCapture(e.pointerId);
    dsx=e.clientX; dsy=e.clientY;
    baseTx=state.uiTx; baseTy=state.uiTy;
  });
  dragHandle.addEventListener("pointermove",(e)=>{
    if(!dragging) return;
    const dx=e.clientX-dsx, dy=e.clientY-dsy;
    const cl=clampTransform(baseTx+dx, baseTy+dy);
    setUITransform(cl.tx, cl.ty);
  });
  dragHandle.addEventListener("pointerup",()=>{ if(!dragging) return; dragging=false; autosave(); });

  // resize panel
  const resizeState={active:false, dir:"", sx:0,sy:0, sw:0,sh:0, btx:0,bty:0};
  function startResize(e,dir){
    sfx("tap");
    e.preventDefault(); e.stopPropagation();
    const r=ui.getBoundingClientRect();
    resizeState.active=true; resizeState.dir=dir;
    resizeState.sx=e.clientX; resizeState.sy=e.clientY;
    resizeState.sw=r.width; resizeState.sh=r.height;
    resizeState.btx=state.uiTx; resizeState.bty=state.uiTy;
    document.addEventListener("pointermove", onResizeMove, {passive:false});
    document.addEventListener("pointerup", onResizeUp, {once:true});
  }
  function onResizeMove(e){
    if(!resizeState.active) return;
    e.preventDefault();
    const dx=e.clientX-resizeState.sx, dy=e.clientY-resizeState.sy;
    let w=resizeState.sw, h=resizeState.sh;
    if(resizeState.dir.includes("e")) w=resizeState.sw+dx;
    if(resizeState.dir.includes("w")) w=resizeState.sw-dx;
    if(resizeState.dir.includes("s")) h=resizeState.sh+dy;
    if(resizeState.dir.includes("n")) h=resizeState.sh-dy;
    w=clamp(w,320,window.innerWidth-28);
    h=clamp(h,240,window.innerHeight-28);
    ui.style.width=w+"px"; ui.style.height=h+"px";
    state.uiW=w; state.uiH=h;

    let tx=resizeState.btx, ty=resizeState.bty;
    if(resizeState.dir.includes("w")) tx=resizeState.btx+dx;
    if(resizeState.dir.includes("n")) ty=resizeState.bty+dy;
    const cl=clampTransform(tx,ty);
    setUITransform(cl.tx, cl.ty);
    autosave();
  }
  function onResizeUp(){
    resizeState.active=false;
    document.removeEventListener("pointermove", onResizeMove);
    autosave();
  }
  ui.querySelectorAll(".handle").forEach(h=>{
    h.addEventListener("pointerdown",(e)=> startResize(e, h.dataset.h), {passive:false});
  });

  // -------- Toggles + sliders
  const blackBg=document.getElementById("blackBg");
  const labels=document.getElementById("labels");
  const slotGuides=document.getElementById("slotGuides");
  blackBg.addEventListener("change",()=>{ sfx("tap"); state.blackBg=blackBg.checked; draw(); autosave(); });
  labels.addEventListener("change",()=>{ sfx("tap"); state.showLabels=labels.checked; draw(); autosave(); });
  slotGuides.addEventListener("change",()=>{ sfx("tap"); state.slotGuides=slotGuides.checked; draw(); autosave(); });

  function bindSlider(id, getter, setter, fmt){
    const el=document.getElementById(id);
    const v=document.getElementById(id+"V");
    let last=0;
    el.addEventListener("input",()=>{
      setter(parseFloat(el.value));
      v.textContent=fmt(getter());
      placeCache.clear();
      draw(); autosave();
      const now=performance.now();
      if(now-last>22){ sfx("slider"); last=now; }
    });
    el.value=getter();
    v.textContent=fmt(getter());
  }
  bindSlider("rx", ()=>state.rxF, v=>state.rxF=v, v=>v.toFixed(2));
  bindSlider("ry", ()=>state.ryF, v=>state.ryF=v, v=>v.toFixed(2));
  bindSlider("spread", ()=>state.spreadF, v=>state.spreadF=v, v=>v.toFixed(2));
  bindSlider("fill", ()=>state.fillA, v=>state.fillA=v, v=>v.toFixed(2));
  bindSlider("tok", ()=>state.tokenScale, v=>state.tokenScale=v, v=>v.toFixed(2));
  bindSlider("slot", ()=>state.slotStep, v=>state.slotStep=v, v=>String(Math.round(v)));

  // creatures controls
  const creaturesT=document.getElementById("creatures");
  const critGlow=document.getElementById("critGlow");
  const dens=document.getElementById("dens");
  const densV=document.getElementById("densV");
  const morph=document.getElementById("morph");
  const morphV=document.getElementById("morphV");
  creaturesT.addEventListener("change",()=>{ sfx("tap"); state.creaturesOn=creaturesT.checked; ensureCreatures(); autosave(); });
  critGlow.addEventListener("change",()=>{ sfx("tap"); state.critGlow=critGlow.checked; autosave(); });
  dens.addEventListener("input",()=>{
    state.density=parseInt(dens.value,10);
    densV.textContent=String(state.density);
    ensureCreatures(); autosave();
    sfx("slider");
  });
  morph.addEventListener("input",()=>{
    state.morphSpeed=parseFloat(morph.value);
    morphV.textContent=state.morphSpeed.toFixed(2);
    autosave();
    sfx("slider");
  });
  document.getElementById("spawnBtn").addEventListener("click",()=>{
    sfx("tap");
    state.creaturesOn=true;
    creaturesT.checked=true;
    ensureCreatures();
    autosave();
  });

  // -------- Buttons
  document.getElementById("randBtn").addEventListener("click",()=>{
    sfx("tap");
    MEMBERS.forEach(m=>state.colors[m]=randColor());
    rebuildLex(); buildCards(); renderChips(); placeCache.clear(); draw(); autosave();
  });
  document.getElementById("pngBtn").addEventListener("click", exportPNG);
  document.getElementById("resetBtn").addEventListener("click",()=>{
    sfx("tap");
    MEMBERS.forEach(m=>state.tokens[m]=[]);
    state.pinned=[];
    creatures.length=0;
    state.creaturesOn=false;
    rebuildLex(); buildCards(); renderChips(); placeCache.clear(); draw(); autosave();
  });
  document.getElementById("recenterBtn").addEventListener("click",()=>{
    sfx("tap");
    state.panX=0; state.panY=0;
    placeCache.clear();
    draw(); autosave();
  });

  // save/load file
  const filePick=document.getElementById("filePick");
  document.getElementById("saveBtn").addEventListener("click",()=>{
    sfx("tap");
    const blob=new Blob([JSON.stringify(snapshot(),null,2)],{type:"application/json"});
    const url=URL.createObjectURL(blob);
    const a=document.createElement("a");
    a.href=url; a.download="slop_counter_data.json"; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 1200);
  });
  document.getElementById("loadBtn").addEventListener("click",()=>{ sfx("tap"); filePick.click(); });
  filePick.addEventListener("change",()=>{
    const f=filePick.files && filePick.files[0]; if(!f) return;
    const reader=new FileReader();
    reader.onload=()=>{
      try{
        applySnapshot(JSON.parse(reader.result));
        syncControls();
        rebuildLex(); buildCards(); renderChips(); placeCache.clear();
        setUITransform(state.uiTx,state.uiTy);
        setHidden(state.uiHidden);
        applyPanelSize();
        ensureCreatures();
        draw(); autosave();
      }catch(e){ alert("Load failed: "+e.message); }
    };
    reader.readAsText(f);
    filePick.value="";
  });

  // -------- Canvas pan (diagram)
  let panning=false, psx=0,psy=0, pbx=0,pby=0;
  function isOverUI(x,y){
    const r=ui.getBoundingClientRect();
    return x>=r.left && x<=r.right && y>=r.top && y<=r.bottom;
  }
  canvas.addEventListener("pointerdown",(e)=>{
    if(isOverUI(e.clientX,e.clientY)) return;
    canvas.setPointerCapture(e.pointerId);
    panning=true;
    psx=e.clientX; psy=e.clientY;
    pbx=state.panX; pby=state.panY;
  });
  canvas.addEventListener("pointermove",(e)=>{
    if(!panning) return;
    state.panX = pbx + (e.clientX-psx);
    state.panY = pby + (e.clientY-psy);
    placeCache.clear();
    draw();
  });
  canvas.addEventListener("pointerup",()=>{ if(!panning) return; panning=false; autosave(); });

  // -------- sync + boot
  function syncControls(){
    blackBg.checked=state.blackBg;
    labels.checked=state.showLabels;
    slotGuides.checked=state.slotGuides;

    document.getElementById("rx").value=state.rxF; document.getElementById("rxV").textContent=state.rxF.toFixed(2);
    document.getElementById("ry").value=state.ryF; document.getElementById("ryV").textContent=state.ryF.toFixed(2);
    document.getElementById("spread").value=state.spreadF; document.getElementById("spreadV").textContent=state.spreadF.toFixed(2);
    document.getElementById("fill").value=state.fillA; document.getElementById("fillV").textContent=state.fillA.toFixed(2);
    document.getElementById("tok").value=state.tokenScale; document.getElementById("tokV").textContent=state.tokenScale.toFixed(2);
    document.getElementById("slot").value=state.slotStep; document.getElementById("slotV").textContent=String(Math.round(state.slotStep));

    creaturesT.checked=state.creaturesOn;
    critGlow.checked=state.critGlow;
    dens.value=state.density; densV.textContent=String(state.density);
    morph.value=state.morphSpeed; morphV.textContent=state.morphSpeed.toFixed(2);
  }
  function applyPanelSize(){
    if(typeof state.uiW==="number") ui.style.width=state.uiW+"px";
    if(typeof state.uiH==="number") ui.style.height=state.uiH+"px";
  }

  // initial colors
  MEMBERS.forEach(m=>state.colors[m]=randColor());
  // load autosave
  try{
    const raw=localStorage.getItem(SAVE_KEY);
    if(raw) applySnapshot(JSON.parse(raw));
  }catch(e){}

  rebuildLex();
  buildCards();
  renderChips();
  syncControls();
  setUITransform(state.uiTx,state.uiTy);
  setHidden(state.uiHidden);
  applyPanelSize();
  ensureCreatures();
  resize();

  // -------- animation loop
  let last=performance.now();
  function loop(now){
    const dt=Math.min(0.05,(now-last)/1000);
    last=now;
    if(state.creaturesOn){ ensureCreatures(); tickCreatures(dt); }
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
